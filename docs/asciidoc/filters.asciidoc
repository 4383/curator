[[filters]]
= Filters

[partintro]
--

Filters are the way to select only the indices (or snapshots) you want.

include::inc_filter_chaining.asciidoc[]

The index filtertypes are:

* <<filtertype_age,age>>
* <<filtertype_alias,alias>>
* <<filtertype_allocated,allocated>>
* <<filtertype_closed,closed>>
* <<filtertype_count,count>>
* <<filtertype_forcemerged,forcemerged>>
* <<filtertype_kibana,kibana>>
* <<filtertype_none,none>>
* <<filtertype_opened,opened>>
* <<filtertype_pattern,pattern>>
* <<filtertype_period,period>>
* <<filtertype_space,space>>

The snapshot filtertypes are:

* <<filtertype_age,age>>
* <<filtertype_count,count>>
* <<filtertype_none,none>>
* <<filtertype_pattern,pattern>>
* <<filtertype_period,period>>
* <<filtertype_state,state>>

You can use <<envvars,environment variables>> in your configuration files.
--

[[filtertype]]
== filtertype

Each filter is defined first by a `filtertype`.  Each filtertype has its own
settings, or no settings at all.  In a configuration file, filters are defined
as follows:

[source,yaml]
-------------
- filtertype: *first*
  setting1: ...
  ...
  settingN: ...
- filtertype: *second*
  setting1: ...
  ...
  settingN: ...
- filtertype: *third*
-------------

The `-` indicates in the YAML that this is an array element.  Each filtertype
declaration must be preceded by a `-` for the filters to be read properly.  This
is how Curator can chain filters together.  Anywhere filters can be used,
multiple can be chained together in this manner.

The index filtertypes are:

* <<filtertype_age,age>>
* <<filtertype_alias,alias>>
* <<filtertype_allocated,allocated>>
* <<filtertype_closed,closed>>
* <<filtertype_count,count>>
* <<filtertype_forcemerged,forcemerged>>
* <<filtertype_kibana,kibana>>
* <<filtertype_none,none>>
* <<filtertype_opened,opened>>
* <<filtertype_pattern,pattern>>
* <<filtertype_period,period>>
* <<filtertype_space,space>>

The snapshot filtertypes are:

* <<filtertype_age,age>>
* <<filtertype_count,count>>
* <<filtertype_none,none>>
* <<filtertype_pattern,pattern>>
* <<filtertype_period,period>>
* <<filtertype_state,state>>

[[filtertype_age]]
== age

[source,yaml]
-------------
 - filtertype: age
   source: name
   direction: older
   timestring: '%Y.%m.%d'
   unit: days
   unit_count: 3
   field:
   stats_result:
   epoch:
   exclude: False
-------------

NOTE: Empty values and commented lines will result in the default value, if any,
    being selected.  If a setting is set, but not used by a given
    <<filtertype,filtertype>>, it may generate an error.

This <<filtertype,filtertype>> will iterate over the actionable list and match
indices based on their age.  They will remain in, or be removed from the
actionable list based on the value of <<fe_exclude,exclude>>.

Read more about the different settings for this <<filtertype,filtertype>>:

[float]
Required settings
~~~~~~~~~~~~~~~~~

* <<fe_source,source>>
* <<fe_direction,direction>>
* <<fe_unit,unit>>
* <<fe_unit_count,unit_count>>

[float]
Dependent settings
~~~~~~~~~~~~~~~~~~

* <<fe_timestring,timestring>> (required if `source` is `name`)
* <<fe_field,field>> (required if `source` is `field_stats`) [Indices only]
* <<fe_stats_result,stats_result>> (only used if `source` is `field_stats`) [Indices only]

[float]
Optional settings
~~~~~~~~~~~~~~~~~

* <<fe_epoch,epoch>>
* <<fe_exclude,exclude>> (default is `False`)


[[filtertype_alias]]
== alias

[source,yaml]
-------------
- filtertype: alias
  aliases:
  exclude: True
-------------

NOTE: Empty values and commented lines will result in the default value, if any,
    being selected.  If a setting is set, but not used by a given
    <<filtertype,filtertype>>, it may generate an error.

This <<filtertype,filtertype>> will iterate over the actionable list and match
indices based on whether they are associated with the given
<<fe_aliases,aliases>>.  They will remain in, or be removed from the actionable
list based on the value of <<fe_exclude,exclude>>.

[float]
Required settings
~~~~~~~~~~~~~~~~~
* <<fe_aliases,aliases>>

[float]
Optional settings
~~~~~~~~~~~~~~~~~
* <<fe_exclude,exclude>> (default is `False`)

[[filtertype_allocated]]
== allocated

[source,yaml]
-------------
- filtertype: allocated
  key:
  value:
  allocation_type:
  exclude: True
-------------

NOTE: Empty values and commented lines will result in the default value, if any,
    being selected.  If a setting is set, but not used by a given
    <<filtertype,filtertype>>, it may generate an error.

This <<filtertype,filtertype>> will iterate over the actionable list and match
indices based on their shard routing allocation settings.  They will remain in,
or be removed from the actionable list based on the value of
<<fe_exclude,exclude>>.

[float]
Required settings
~~~~~~~~~~~~~~~~~

* <<fe_key,key>>
* <<fe_value,value>>

[float]
Optional settings
~~~~~~~~~~~~~~~~~
* <<fe_allocation_type,allocation_type>>
* <<fe_exclude,exclude>> (default is `True`)


[[filtertype_closed]]
== closed

[source,yaml]
-------------
- filtertype: closed
  exclude: True
-------------

This <<filtertype,filtertype>> will iterate over the actionable list and match
indices which are closed.  They will remain in, or be removed from the
actionable list based on the value of <<fe_exclude,exclude>>.

[float]
Optional settings
~~~~~~~~~~~~~~~~~

* <<fe_exclude,exclude>> (default is `True`)

[[filtertype_count]]
== count

[source,yaml]
-------------
- filtertype: count
  count: 10
  reverse: True
  use_age: False
  source: creation_date
  timestring:
  field:
  stats_result:
  exclude: False
-------------

NOTE: Empty values and commented lines will result in the default value, if any,
    being selected.  If a setting is set, but not used by a given
    <<filtertype,filtertype>>, it may generate an error.

This <<filtertype,filtertype>> will iterate over the actionable list of indices
_or_ snapshots. They are ordered by age, or by alphabet, so as to guarantee
that the correct items will remain in, or be removed from the actionable list
based on the values of <<fe_count,count>>, <<fe_exclude,exclude>>, and
<<fe_reverse,reverse>>.

For use cases, where "like" items are being counted, and their name pattern
guarantees date sorting is equal to alphabetical sorting, it is unnecessary to
set <<fe_use_age,use_age>> to `True`, as item names will be sorted in
<<fe_reverse,reverse>> order by default.  This means that the item count will
start beginning with the _newest_ indices or snapshots, and proceed through to
the oldest.

Read more about the different settings for this <<filtertype,filtertype>>:

[float]
Required settings
~~~~~~~~~~~~~~~~~

* <<fe_count,count>>

[float]
Optional settings
~~~~~~~~~~~~~~~~~

* <<fe_reverse,reverse>>
* <<fe_use_age,use_age>>
* <<fe_source,source>> (required if `use_age` is `True`)
* <<fe_timestring,timestring>> (required if `source` is `name`)
* <<fe_exclude,exclude>> (default is `False`)

[float]
Index-only settings
~~~~~~~~~~~~~~~~~~~

* <<fe_field,field>> (required if `source` is `field_stats`)
* <<fe_stats_result,stats_result>> (only used if `source` is `field_stats`)


[[filtertype_forcemerged]]
== forcemerged

[source,yaml]
-------------
- filtertype: forcemerged
  max_num_segments: 2
  exclude: True
-------------

NOTE: Empty values and commented lines will result in the default value, if any,
    being selected.  If a setting is set, but not used by a given
    <<filtertype,filtertype>>, it may generate an error.

This <<filtertype,filtertype>> will iterate over the actionable list and match
indices which have `max_num_segments` segments per shard, or fewer.  They will
remain in, or be removed from the actionable list based on the value of
<<fe_exclude,exclude>>.

[float]
Required settings
~~~~~~~~~~~~~~~~~

* <<fe_max_num_segments,max_num_segments>>

[float]
Optional settings
~~~~~~~~~~~~~~~~~

* <<fe_exclude,exclude>> (default is `True`)

[[filtertype_kibana]]
== kibana

[source,yaml]
-------------
- filtertype: kibana
  exclude: True
-------------

This <<filtertype,filtertype>> will remove indices `.kibana`, `.marvel-kibana`,
`kibana-int`, and `.marvel-es-data` from the list of indices, if present.

This <<filtertype,filtertype>> will iterate over the actionable list and match
indices `.kibana`, `.marvel-kibana`, `kibana-int`, or `.marvel-es-data`. They
will remain in, or be removed from the actionable list based on the value of
<<fe_exclude,exclude>>.

[float]
Optional settings
~~~~~~~~~~~~~~~~~

* <<fe_exclude,exclude>> (default is `True`)


[[filtertype_none]]
== none

[source,yaml]
-------------
- filtertype: none
-------------

This <<filtertype,filtertype>> will not filter anything, returning the full
list of indices or snapshots.

There are no settings for this <<filtertype,filtertype>>.


[[filtertype_opened]]
== opened

[source,yaml]
-------------
- filtertype: opened
  exclude: True
-------------

This <<filtertype,filtertype>> will iterate over the actionable list and match
indices which are opened.  They will remain in, or be removed from the
actionable list based on the value of <<fe_exclude,exclude>>.

[float]
Optional settings
~~~~~~~~~~~~~~~~~

* <<fe_exclude,exclude>> (default is `True`)




[[filtertype_pattern]]
== pattern

[source,yaml]
-------------
- filtertype: pattern
 kind: prefix
 value: logstash-
 exclude: False
-------------

NOTE: Empty values and commented lines will result in the default value, if any,
    being selected.  If a setting is set, but not used by a given
    <<filtertype,filtertype>>, it may generate an error.

This <<filtertype,filtertype>> will iterate over the actionable list and match
indices matching a given pattern.  They will remain in, or be removed from
the actionable list based on the value of <<fe_exclude,exclude>>.

include::inc_filter_chaining.asciidoc[]

Read more about the different settings for this <<filtertype,filtertype>>:

[float]
Required settings
~~~~~~~~~~~~~~~~~

* <<fe_kind,kind>>
* <<fe_value,value>>

[float]
Optional settings
~~~~~~~~~~~~~~~~~

* <<fe_exclude,exclude>> (default is `False`)



[[filtertype_period]]
== period

This <<filtertype,filtertype>> will iterate over the actionable list and match
indices or snapshots based on whether they fit within the given time range.
They will remain in, or be removed from the actionable list based on the value
of <<fe_exclude,exclude>>.

[source,yaml]
-------------
 - filtertype: period
   source: name
   range_from: -1
   range_to: -1
   timestring: '%Y.%m.%d'
   unit: weeks
   week_starts_on: sunday
-------------

NOTE: Empty values and commented lines will result in the default value, if any,
    being selected.  If a setting is set, but not used by a given
    <<filtertype,filtertype>>, it may generate an error.

=== Periods, or Date Ranges

For the purposes of this filter, a <<fe_unit,unit>> can be one of `hours`,
`days`, `weeks`, `months`, or `years`.  Unless an <<fe_epoch,epoch>> timestamp
is provided, reckoning will be centered on execution time.  Reckoning is
truncated to the most recent whole unit.  For example, if I selected `hours` as
my `unit`, and I began execution at 02:35, then the point of reckoning would be
02:00. This is relatively easy with `days`, `months`, and `years`, but slightly
more complicated with `weeks`. Some users may wish to reckon weeks by the ISO
standard, which starts weeks on Monday. Others may wish to use Sunday as the
first day of the week.  Both are acceptable options with the `period` filter.
The default behavior for `weeks` is to have Sunday be the start of the week.
This can be overridden with <<fe_week_starts_on,week_starts_on>> as follows:

[source,yaml]
-------------
 - filtertype: period
   source: name
   range_from: -1
   range_to: -1
   timestring: '%Y.%m.%d'
   unit: weeks
   week_starts_on: monday
-------------

<<fe_range_from,range_from>> and <<fe_range_to,range_to>> are counters of whole
<<fe_unit,units>>. A negative number indicates a whole unit in the past, while
a positive number indicates a whole unit in the future. A `0` indicates the
present unit. With such a timeline mentality, it is relatively easy to create
a date range that will meet your needs.

If the time of execution time is *2017-04-03T13:45:23.831*, this table will help
you figure out what the previous whole unit, current unit, and next whole unit
will be, in ISO8601 format.

[frame="topbot",options="header"]
|======================================================================
|unit      |-1                 |0                  |+1
|hours     |2017-04-03T12:00:00|2017-04-03T13:00:00|2017-04-03T14:00:00
|days      |2017-04-02T00:00:00|2017-04-03T00:00:00|2017-04-04T00:00:00
|weeks sun |2017-03-26T00:00:00|2017-04-02T00:00:00|2017-04-09T00:00:00
|weeks mon |2017-03-27T00:00:00|2017-04-03T00:00:00|2017-04-10T00:00:00
|months    |2017-03-01T00:00:00|2017-04-01T00:00:00|2017-05-01T00:00:00
|years     |2016-01-01T00:00:00|2017-01-01T00:00:00|2018-01-01T00:00:00
|======================================================================

Ranges must be from older dates to newer dates, or smaller numbers (including
negative numbers) to larger numbers or Curator will return an exception.

An example `period` filter demonstrating how to select all daily indices by
timestring found in the index name from last month might look like this:

[source,yaml]
-------------
 - filtertype: period
   source: name
   range_from: -1
   range_to: -1
   timestring: '%Y.%m.%d'
   unit: months
-------------

Having `range_from` and `range_to` both be the same value will mean that only
that whole unit will be selected, in this case, a month.

=== Settings

[float]
Required settings
~~~~~~~~~~~~~~~~~

* <<fe_source,source>>
* <<fe_range_from,range_from>>
* <<fe_range_to,range_to>>
* <<fe_unit,unit>>

[float]
Dependent settings
~~~~~~~~~~~~~~~~~~

* <<fe_timestring,timestring>> (required if `source` is `name`)
* <<fe_field,field>> (required if `source` is `field_stats`) [Indices only]
* <<fe_stats_result,stats_result>> (only used if `source` is `field_stats`) [Indices only]

[float]
Optional settings
~~~~~~~~~~~~~~~~~

* <<fe_epoch,epoch>>
* <<fe_exclude,exclude>> (default is `False`)
* <<fe_week_starts_on,week_starts_on>>



[[filtertype_space]]
== space

[source,yaml]
-------------
- filtertype: space
  disk_space: 100
  reverse: True
  use_age: False
  source: creation_date
  timestring:
  field:
  stats_result:
  exclude: False
-------------

NOTE: Empty values and commented lines will result in the default value, if any,
    being selected.  If a setting is set, but not used by a given
    <<filtertype,filtertype>>, it may generate an error.

This <<filtertype,filtertype>> will iterate over the actionable list and match
indices when their cumulative disk consumption exceeds
<<fe_disk_space,disk_space>> gigabytes.  They are first ordered by age,
or by alphabet, so as to guarantee the oldest indices are deleted first. They
will remain in, or be removed from the actionable list based on the value of
<<fe_exclude,exclude>>.

[float]
Deleting Indices By Space
~~~~~~~~~~~~~~~~~~~~~~~~~

This <<filtertype,filtertype>> is for those who want to retain indices based on
disk consumption, rather than by a set number of days. There are some important
caveats regarding this choice:

* Elasticsearch cannot calculate the size of closed indices. Elasticsearch does
  not keep tabs on how much disk-space closed indices consume. If you close
  indices, your space calculations will be inaccurate.
* Indices consume resources just by existing. You could run into performance
  and/or operational snags in Elasticsearch as the count of indices climbs.
* You need to manually calculate how much space across all nodes. The total you
  give will be the sum of all space consumed across all nodes in your cluster.
  If you use shard allocation to put more shards or indices on a single node, it
  will not affect the total space reported by the cluster, but you may still run
  out of space on that node.

These are only a few of the caveats. This is still a valid use-case, especially
for those running a single-node test box.

NOTE: The <<fe_reverse,reverse>> option will be ignored if
    <<fe_use_age,use_age>> is `True`

For use cases, where "like" indices are being counted, and their name pattern
guarantees date sorting is equal to alphabetical sorting, it is unnecessary to
set <<fe_use_age,use_age>> to `True`, as index names will be sorted in
<<fe_reverse,reverse>> order by default.  For this case, this means that disk
space calculations will start beginning with the _newest_ indices, and
proceeding through to the oldest.

Read more about the different settings for this <<filtertype,filtertype>>:

[float]
Required settings
~~~~~~~~~~~~~~~~~

* <<fe_disk_space,disk_space>>

[float]
Optional settings
~~~~~~~~~~~~~~~~~

* <<fe_reverse,reverse>>
* <<fe_use_age,use_age>>
* <<fe_source,source>> (required if `use_age` is `True`)
* <<fe_timestring,timestring>> (required if `source` is `name`)
* <<fe_field,field>> (required if `source` is `field_stats`)
* <<fe_stats_result,stats_result>> (only used if `source` is `field_stats`)
* <<fe_exclude,exclude>> (default is `False`)

[[filtertype_state]]
== state

[source,yaml]
-------------
- filtertype: state
  state: SUCCESS
  exclude: False
-------------

NOTE: Empty values and commented lines will result in the default value, if any,
    being selected.  If a setting is set, but not used by a given
    <<filtertype,filtertype>>, it may generate an error.

This <<filtertype,filtertype>> will iterate over the actionable list and match
snapshots based on the value of <<fe_state,state>>.  They will remain in, or be
removed from the actionable list based on the value of <<fe_exclude,exclude>>.

[float]
Required settings
~~~~~~~~~~~~~~~~~

* <<fe_state,state>>

[float]
Optional settings
~~~~~~~~~~~~~~~~~

* <<fe_exclude,exclude>> (default is `False`)
